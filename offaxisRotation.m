%% Try out a prolate ellipsoid but with Omega = en, testing the ability of the combined
% ansatz to account for the rotlet-induced translation.
addpath(genpath('.'))

methodsToDo = {'rotletAnsatz','combinedAnsatz','combinedAnsatzRTTBCApprox'};

%% Setup parameters.
params = struct();

% Slenderness parameter.
params.epsilon = 1e-2;

% Level of numerical discretisation (number of segments on which force and
% torque are treated as constant).
params.N = 400;

selections = struct();

selections.A.name = 'A';
selections.A.xiSelector = 1;
selections.A.etaSelector = 1;
selections.A.angVelSelector = 2;
selections.A.linVelSelector = 1;

selections.B.name = 'B';
selections.B.xiSelector = 2;
selections.B.etaSelector = 1;
selections.B.angVelSelector = 2;
selections.B.linVelSelector = 1;

selections.C.name = 'C';
selections.C.xiSelector = 3;
selections.C.etaSelector = 1;
selections.C.angVelSelector = 2;
selections.C.linVelSelector = 1;

selections.D.name = 'D';
selections.D.xiSelector = 4;
selections.D.etaSelector = 1;
selections.D.angVelSelector = 2;
selections.D.linVelSelector = 1;

% Set the number of arclengths to sample when evaluating the velocity
% generated by the ansaetze.
params.numArclengthEvaluationPoints = 51;

% Set the number of points on a cross section to sample when evaluating the
% velocity generated by the ansaetze.
params.numCircumferentialEvaluationPoints = 12;

params.verbose = true;

sels = fieldnames(selections);
for i = 1 : numel(sels)
    sel = selections.(sels{i});

    params.xiSelector = sel.xiSelector;
    params.etaSelector = sel.etaSelector;
    params.angVelSelector = sel.angVelSelector;
    params.linVelSelector = sel.linVelSelector;

    % Evaluate the SBT ansaetze.
    output = evaluateSBT(params, methodsToDo);

    % Evaluate the error in the velocity fields.
    errors = struct();
    for name = methodsToDo
        name = name{1};
        errors.(name) = evalVelErrors(name, output);
    end

    save(['output/offaxisRotation/',sel.name,'.mat'],'params','output','errors')

end